
const handleHome = () => {
  const html = `<!doctype html>
<html lang=en>
<head>
  <meta charset=utf-8>
  <title>Streaming List</title>
  <meta name=viewport content=width=device-width,initial-scale=1>
</head>
<body>
  <h1>Streaming List</h1>
  <p>Construct a long HTML list response in Service Worker and stream it into the browser.</p>
  <p><a href=/streaming-list-demo/list>Take me to the list</a></p>
  <p>(This html has been generated by Service Worker)</p>
  <script>
    navigator.serviceWorker.register('sw.js')
  </script>
</body>`

  return new Response(html, {
    status: 200,
    headers: {
      "Content-Type": "text/html; charset=utf-8",
    }
  })
}

const handleNotFound = () => {
  const html = `<!doctype html>
<html lang=en>
<head>
  <meta charset=utf-8>
  <title>404 Not Found</title>
  <meta name=viewport content=width=device-width,initial-scale=1>
</head>
<body>404 Not Found`

  return new Response(html, {
    status: 404,
    headers: {
      "Content-Type": "text/html; charset=utf-8",
    }
  })
}

const splitStream = splitOn => {
  let buffer = ""
  return new TransformStream({
    transform(chunk, controller) {
      buffer += chunk
      const parts = buffer.split(splitOn)
      parts.slice(0, -1).forEach(part => controller.enqueue(part))
      buffer = parts[parts.length - 1]
    },
    flush(controller) {
      if (buffer) controller.enqueue(buffer)
    }
  })
}

const buildHTMLStream = () => {
  let isFirst = true
  const encoder = new TextEncoder()

  return new TransformStream({
    transform(json, controller) {
      let jsonToParse
      if (isFirst) {
        jsonToParse = json.substr(1) + '}'
        isFirst = false
        const head = `<!doctype html>
<html lang=en>
<head>
  <meta charset=utf-8>
  <title>Streaming List Result</title>
  <meta name=viewport content=width=device-width,initial-scale=1>
</head>
<body>
  <h1>Streaming List</h1>
  <p>This html has been generated by Service Worker, which fetches a <a href="https://raw.githubusercontent.com/prust/wikipedia-movie-data/master/movies.json">huge json</a> (36.273 entries) from a server, stream-decodes it and streams it to the browser.</p>
  `
        controller.enqueue(encoder.encode(head))
      } else {
        jsonToParse = '{' + json + '}'
      }
      console.log("parsing json", jsonToParse)
      const data = JSON.parse(jsonToParse)
      console.log("parsed json", data)

      const { title, extract, href } = data

      if (!title || !extract) {
        return
      }
      const linkedTitle = href ? `<a href="https://en.wikipedia.org/wiki/${href}">${title}</a>` : title
      const html = `
      <article>
        <h2>${linkedTitle}</h2>
        <p>${extract}</p>
      </article>
      `
      
      controller.enqueue(encoder.encode(html))
    }
  })
}

const handleListStream = async () => {
  const url = 'https://raw.githubusercontent.com/prust/wikipedia-movie-data/master/movies.json'

  console.log("Service Worker requesting url", url)

  const response = await fetch(url)

  if (response.status !== 200) {
    console.error("problem with resource", response.status)
    return handleNotFound()
  }

  const htmlStream = response.body
    .pipeThrough(new TextDecoderStream())
    .pipeThrough(splitStream("  },\n  {"))
    .pipeThrough(buildHTMLStream())

  return new Response(htmlStream, {
    headers: {
      "Content-Type": "text/html; charset=utf-8",
    }
  })
}

const dispatch = async event => {
  const { url, method } = event.request
  const { pathname, hash } = new URL(url)

  console.log("Service worker dipatching", { method, pathname, hash })

  if (pathname === "/favicon.ico") {
    return fetch(event.request.clone())
  }
  
  if (method === "GET") {
    switch (pathname) {
      case "/streaming-list-demo/list":
        return handleListStream()
        break
      case "/streaming-list-demo/":
        return handleHome()
        break
      default:
        return fetch(event.request.clone())
        break
    }
  } else {
    return handleNotFound()
  }
}

self.addEventListener('fetch', event => event.respondWith(dispatch(event)))
self.addEventListener('install', event => self.skipWaiting())
